# Effective Mobile Test Task

# СОДЕРЖАНИЕ

[1. Запуск проекта](#1-запуск-проекта)
- [1.1. Запуск с использованием Docker](#11-запуск-с-использованием-docker)
- [1.2. Установка зависимостей (если не используете Docker)](#12-установка-зависимостей-если-не-используете-docker)
- [1.3. Работа с базой данных](#13-работа-с-базой-данных)

[2. Инструкция по использованию](#2-инструкция-по-использованию)
- [2.1. Пользователи системы](#21-пользователи-системы)
- [2.2. Внутренний функционал системы](#22-внутренний-функционал-системы)
- [2.3. Внешний функционал системы](#23-внешний-функционал-системы)

[3. База данных](#3-база-данных)
- [3.1. Модель Users (Пользователи)](#31-модель-users-пользователи)
- [3.2. Модель Roles (Роли)](#32-модель-roles-роли)
- [3.3. Модель UserRoles (Роли пользователей)](#33-модель-userroles-роли-пользователей)
- [3.4. Модель Passwords (Пароли)](#34-модель-passwords-пароли)
- [3.5. Модель EntryMonitoring (Мониторинг действий)](#35-модель-entrymonitoring-мониторинг-действий)

[4. Особенности системы](#4-особенности-системы)
- [4.1. Кастомная система аутентификации ./effMobApp/usersAction/authentication.py](#41-кастомная-система-аутентификации-effmobappusersactionauthenticationpy)
- [4.2. Кастомная модель пользователя](#42-кастомная-модель-пользователя)
- [4.3. Класс CustomUserManager](#43-класс-customusermanager)
- [4.4. Работа с паролями (./effMobApp/usersAction/passwords.py)](#44-работа-с-паролями-effmobappusersactionpasswordspy)
- [4.5. Два API: внешний и внутренний](#45-два-api-внешний-и-внутренний)
- [4.6. UserSerializer (./effMobApp/serializers.py)](#46-userserializer-effmobappserializerspy)

[TO DO](#todo)
- [1. Уровневая система доступа в расширенных сущностях](#1-уровневая-система-доступа-в-расширенных-сущностях)
- [2. Работа над пользовательскими паролями](#2-работа-над-пользовательскими-паролями)
- [3. Заполнять таблицу entryMonitoring](#3-заполнять-таблицу-entrymonitoring)
- [4. Возможность создания администратора](#4-возможность-создания-администратора)
- [5. Предоставить администраторам возможность "мягко" удалять пользователей](#5-предоставить-администраторам-возможность-мягко-удалять-пользователей)

---

## 1. Запуск проекта

### 1.1. Запуск с использованием Docker

1. Клонируйте репозиторий:

    ```bash
    git clone https://github.com/DashaOdnostorontseva/testEffMob/
    cd <папка с проектом>
    ```

2. Построить контейнеры:

    ```bash
    docker-compose up --build
    ```

3. Откройте [http://localhost:8000](http://localhost:8000) в браузере.

---

### 1.2. Установка зависимостей (если не используете Docker)

1. Создайте виртуальное окружение:

    ```bash
    python -m venv venv
    ```

2. Активируйте виртуальное окружение:

    - Windows:
      ```bash
      .\venv\Scripts\activate
      ```

    - macOS/Linux:
      ```bash
      source venv/bin/activate
      ```
3. В файле settings.py (./testEffMob/settings.py) на строке 105 замените 'HOST': 'db' на 'HOST': 'loacalhost'

3. Установите зависимости:

    ```bash
    pip install -r requirements.txt
    ```

4. Выполните миграции:

    ```bash
    python manage.py migrate
    ```
    
5. Заполните базу данных тестовыми данными:

    ```bash
    python loaddata.py
    ```  

6. Запустите сервер:

    ```bash
    python manage.py runserver
    ```
---

### 1.3. Работа с базой данных

1. Подключение к базе данных

   ```bash
      psql -U root -d testeffmob
   ```  

   > пароль: root

2. Просмотр всех таблицы:

   ```bash
      \dt
   ```  
   Список таблиц из базы данных системы:
   - **`effMobApp_entrymonitoring`**
   - **`effMobApp_passwords`**
   - **`effMobApp_roles`**
   - **`effMobApp_userroles`**
   - **`effMobApp_users`**

3. Пример запроса к базе данных:

   ```sql
      SELECT * FROM "public"."effMobApp_userroles";
   ``` 

4. Выход:

   ```bash
      \q
   ```  

## 2. Инструкция по использованию

### 2.1. Пользователи системы

Система поддерживает три роли пользователей:

- **User** — обычный пользователь, имеющий доступ к своему профилю и функционалу для авторизованных пользователей.
- **Operator** — оператор, имеет доступ к странице оператора, а также возможность изменять данные пользователей в системе.
- **Admin** — администратор, имеет доступ ко всем страницам, может изменять пользовательские роли.

#### Примеры аккаунтов, которые уже существуют в системе (если вы выполнили п.1.2 или п.1.5):

- **1 - User**:
  - **Логин**: petr@mail.ru
  - **Пароль**: 123

- **2 - Operator**:
  - **Логин**: ivan@mail.ru
  - **Пароль**: 123

- **3 - Admin**:
  - **Логин**: daria@mail.ru
  - **Пароль**: 333

> Примечание: Администратор может изменять роли всех пользователей в системе.
---

### 2.2. Внутренний функционал системы

Система включает в себя несколько страниц, каждая из которых имеет определенные функции и ограничения доступа:

1. **Авторизация** (Главная страница):
   - Страница, где пользователь может войти в систему или зарегистрироваться.
   - Доступна всем пользователям.

2. **Профиль**:
   - Доступна только авторизованным пользователям для просмотра личной информации.
   - На этой странице доступны кнопки для перехода на другие страницы (например, редактирование профиля, выхож из системы и другие).

3. **Страница администратора**:
   - Страница доступна только авторизованным пользователям с ролью **"Администратор"**.
   - На данной странице администратор может менять роли пользователей системы без использования внешнего API.

4. **Страница оператора**:
   - Страница доступна авторизованным пользователям с ролью **"Оператор"** и **"Администратор"**.
   - Данная страница содержит в себе только текстовое поле.

5. **Страница пользовательская**:
   - Страница доступна только авторизованным пользователям.
   - Данная страница содержит в себе только текстовое поле.

6. **Редактирование профиля**:
   - Доступна авторизованным пользователям.
   - Пользователи могут изменять свои персональные данные, а также менять пароль.
   - При смене пароля происходит автоматический выход из системы и переход на страницу входа.

7. **Удаление профиля**:
   - Когда пользователь удаляет свой профиль, его статус **`is_active`** меняется на **`False`**, что деактивирует его. После чего вход в систему для данного пользователя невозможен.
   - В поле **`deleted_at`** сохраняется время удаления, что позволяет отслеживать момент деактивации профиля.
   - Профиль остается в базе данных, но его можно восстановить, изменив статус на **`True`**. Восстановление профиля возможно путем повторной регистрации в системе с последними **`email`** и **`password`**, которые были сохранены до удаления профиля.

8. **Выход из системы**:
   - При выходе из системы сессия пользователя завершается.
   - После выхода пользователь перенаправляется на главную страницу.

> Примечание: Страницы, описанные в пп. 3, 4 и 5 реализованы для демонстрации работоспособности разграничения пользовательских ролей.
---

### 2.3. Внешний функционал системы

Система реализует **JWT API** (JSON Web Token API), который позволяет пользователям с ролью **"Администратор"** получать данные о всех пользователях в формате JSON.

### API для администратора:
- Администратор может использовать API для получения информации о всех пользователях.
- API доступно только пользователям с ролью **"Администратор"**.

#### Пример запроса:
- На главной странице имеется кнопка для тестирования внешнего API.
- Также можно протестировать API другими способами, например, с помощью Python.

### Пример кода для тестирования API на Python:

```python
import requests

BASE = "http://localhost:8000"  # поменяйте в зависимости от метода запуска системы (п.1)
TOKEN_URL = f"{BASE}/api/token/"
USERS_URL = f"{BASE}/external/users/"
UPDATE_ROLE_URL = f"{BASE}/external/update_role/"

ADMIN_ROLE = "admin"
OPER_ROLE = "operator"
USER_ROLE = "user"

TIMEOUT = 10

email = "daria@mail.ru"
password = "333"

payload = {"email": email, "password": password}
r = requests.post(TOKEN_URL, json=payload, timeout=TIMEOUT)
r.raise_for_status()  # выбросит исключение для 4xx/5xx
data = r.json()

print("Access token:", data)

######################################################

access_token = data["access"]
headers = {"Authorization": f"Bearer {access_token}"}
r = requests.get(USERS_URL, headers=headers, timeout=TIMEOUT)
r.raise_for_status()
res = r.json()
print(res)

######################################################

headers = {"Authorization": f"Bearer {access_token}", "Content-Type": "application/json"}
payload = {"user_id": "3", "role_type": USER_ROLE} # вы можете использовать другие данные
r = requests.post(UPDATE_ROLE_URL, headers=headers, json=payload, timeout=TIMEOUT)
r.raise_for_status()
r.json()
```
---

## 3. База данных

![Схема базы данных системы](images/DB_scheme.png)

В проекте используется несколько моделей для управления пользователями, ролями, историей паролей, мониторингом действий и прочими сущностями.

### 3.1. Модель Users (Пользователи)

Модель **`Users`** представляет пользователей системы и наследуется от **`AbstractBaseUser`**, что позволяет кастомизировать процесс аутентификации.

#### Поля:
- **`date`**: Дата и время создания пользователя (автоматически устанавливается).
- **`first_name`**: Имя пользователя.
- **`last_name`**: Фамилия пользователя.
- **`patronymic`**: Отчество пользователя (опционально).
- **`email`**: Электронная почта пользователя (уникальное поле).
- **`password`**: Хэшированный пароль пользователя.
- **`last_modified`**: Дата и время последнего изменения данных пользователя.
- **`is_active`**: Флаг активности пользователя (по умолчанию `True`).
- **`deleted_at`**: Дата и время мягкого удаления пользователя (если применимо).

---

### 3.2. Модель Roles (Роли)

Модель **`Roles`** представляет различные роли пользователей в системе.

#### Поля:
- **`date`**: Дата и время создания роли (автоматически устанавливается).
- **`role_type`**: Тип роли ("user", "operator", "admin").

---

### 3.3. Модель UserRoles (Роли пользователей)

Модель **`UserRoles`** представляет связь между пользователями и ролями. Она позволяет назначать одну пользоветальскую роль, а также проследить изменения ролей у пользователя (исторические данные).

#### Поля:
- **`date`**: Дата и время назначения роли (автоматически устанавливается).
- **`user`**: Внешний ключ на модель **`Users`** (пользователь).
- **`role`**: Внешний ключ на модель **`Roles`** (роль).
- **`created_by`**: Внешний ключ на модель **`Users`** (пользователь, который назначил роль). Может быть **`NULL`**.

---

### 3.4. Модель Passwords (Пароли)

Модель **`Passwords`** хранит исторические пароли пользователей. Это позволяет отслеживать старые пароли, а также предотвратить их повторное использование (исторические данные).

#### Поля:
- **`date`**: Дата и время сохранения пароля (автоматически устанавливается).
- **`user`**: Внешний ключ на модель **`Users`** (пользователь).
- **`salt`**: Соль для хэширования пароля (необходимо для сверки "нового" и "старого" пароля в дальнейшем - см. TODO).
- **`hashed_password`**: Хэшированный пароль.

---

### 3.5. Модель EntryMonitoring (Мониторинг действий)

Модель **`EntryMonitoring`** используется для мониторинга действий пользователей в системе. Она записывает информацию о том, какие действия были выполнены пользователем, а также его IP-адрес (исторические данные).

### Поля:
- **`date`**: Дата и время действия.
- **`user`**: Внешний ключ на модель **`Users`** (пользователь).
- **`action`**: Описание действия, которое выполнил пользователь.
- **`ip_address`**: IP-адрес пользователя, с которого было выполнено действие.

---

## 4. Особенности системы

### 4.1. Кастомная система аутентификации ./effMobApp/usersAction/authentication.py

Для выполнения условия задания реализован собственный backend для аутентификации пользователей — **`CustomAuthenticationBackend`**.

По заданию требовалось реализовать **собственную систему аутентификации и авторизации**, не полностью основанную на стандартных механизмах "из коробки". Алгоритм работы:

- Пользователь вводит email и пароль.
- Система ищет пользователя в модели Users.
- Из таблицы Passwords извлекается последняя запись (актуальный хэш и соль).
- Введённый пароль объединяется с солью и сравнивается с хэшем из базы данных при помощи функции check_password().
- Если проверка успешна — пользователь аутентифицируется, иначе доступ отклоняется.


---

### 4.2. Кастомная модель пользователя 

В проекте используется собственная модель `Users`, наследуемая от `AbstractBaseUser`, что дало возможность:
- отказаться от встроенной модели `User`;
- задать уникальное поле для аутентификации (**`email`**, вместо стандартного `username`);
- добавить дополнительные атрибуты и методы управления пользователем.

- **Методы**:
  - `soft_delete()` — реализует мягкое удаление без физического удаления записи из базы данных;
  - `restore()` — восстанавливает пользователя после удаления;
  - `update_profile_info()` — обновляет данные профиля пользователя;
  - `update_last_modified()` — обновляет поле времени последнего изменения при любых изменениях.

---

### 4.3. Класс CustomUserManager

Поскольку модель `Users` не основана на стандартной модели `User`, необходимо было переопределить менеджер пользователей, чтобы корректно создавать объекты.  
Для этого реализован **кастомный менеджер** `CustomUserManager`, унаследованный от `BaseUserManager`.

#### Метод `create_user()` переопределен для:
- нормализации email перед сохранением (`self.normalize_email(email)`);
- задания пользовательских полей при создании;
- явного сохранения нового пользователя в базе данных.

---

### 4.4. Работа с паролями (./effMobApp/usersAction/passwords.py)

В проекте реализован отдельный модуль **`passwords.py`**, отвечающий за создание и обновление паролей пользователей.  

Основные функции:

- hash_password(password) - отвечает за генерацию соли и хэширование пароля.  

Такой подход делает невозможным обратное восстановление исходного пароля и защищает систему от атак по словарю и радужным таблицам.

- update_password(user, password) - используется при смене пароля пользователем (создает новый хэш и соль через вызов `hash_password()`, обновляет поле `password` у пользователя в таблице `Users` и сохраняет запись в таблице `Passwords`, для сохранения истории всех паролей пользователя.

---

### 4.5. Два API: внешний и внутренний

В проекте реализованы **два API** — внешний (**`externalApi.py`**) и внутренний (**`internalApi.py`**).  
Оба модуля работают со схожим функционалом (получение списка пользователей, изменение ролей и т.п.), но имеют **разные цели**.

#### Внешний API (./effMobApp/API/externalApi.py)

Предназначен для взаимодействия с системой извне — например, через Postman, curl, Python-скрипты или другие интеграции. Он защищён JWT-аутентификацией и предназначен для безопасного обмена данными с внешними клиентами. Особенности:

- Использует JWTAuthentication и IsAuthenticated из rest_framework_simplejwt.
- Требует наличия корректного JWT-токена.
- Проверяет роль пользователя в системе и возвращает ответ только для администраторов.


#### Внутренний API (./effMobApp/API/internalApi.py)

Используется внутри системы — при взаимодействии между профилем пользователя и административной панелью. Он работает в пределах самой платформы и предполагает, что пользователь уже авторизован через внутренние механизмы Django. Особенности:

- Использует стандартную аутентификацию IsAuthenticated;
- Работает в связке с сессией Django;
- Позволяет администраторам изменять роли, получать список пользователей и управлять системой без использования внешних токенов.

### 4.6. UserSerializer (./effMobApp/serializers.py)

Для корректной передачи данных между сервером и клиентом в проекте используется **сериализация** (объекты моделей Django преобразуются в **JSON**).  

Класс **`UserSerializer`** был реализован для преобразования данных модели `Users` в JSON-структуру, удобную для передачи данных по сети. Принцип работы:

- При обращении к API Django получает список пользователей из базы, затем они передаются в сериализатор.
- Сериализатор извлекает основные поля из модели Users, вызывает методы get_role_type() и get_role_date() для каждого пользователя и формирует итоговую JSON-структуру для ответа API.

---

## TODO

### 1. Уровневая система доступа в расширенных сущностях

Система разработана с учетом будущего расширения при релализации других сущностей системы (например, **деревья файлов** или **узлы деревьев**). Для каждой из этих сущностей будет определен свой **`ACCESS_LEVEL`**.

- В системе три роли: **`user (id = 1)`**, **`operator (id = 2)`**, **`admin (id = 3)`**
- **`ACCESS_LEVEL`** будет определять, какая роль необходима пользователю для взаимодействия с определенной сущностью (например, деревом или его узлом).
- Каждая сущность, например **`fileTree`**, **`systemFiles`**, **`userFiles`**, или **`officeFiles`**, будет иметь свой заранее определенный (заданный, как константа) **`ACCESS_LEVEL`**, который будет сравниваться с ролью пользователя перед предоставлением доступа.

Пример работы с сущностями и уровнями доступа:

1. Каждому дереву и(или) узлу дерева (например, будут созданы узлы - **`systemFiles`**, **`userFiles`** или **`officeFiles`**) будет присвоен **`ACCESS_LEVEL`**.
2. Когда пользователь захочет просматривать или взаимодействовать с узлом в дереве, система сначала сравнит его user_role_id и **`ACCESS_LEVEL`** сущности.
3. Если роль пользователя позволяет доступ к этому узлу (т.е. id пользовательской роли >= нужного уровня для узла), то доступ будет предоставлен.

---

### 2. Работа над пользовательскими паролями

Для улучшения безопасности системы необходимо реализовать механизм проверки пароля, который предотвратит использование **старых паролей** и обеспечит минимальные требования к сложности пароля, а именно:

- Реализовать проверку, чтобы пользователь не мог использовать свой **предыдущий пароль** при создании нового пароля. Для этого используется таблица **`Passwords`**, которая хранит историю паролей пользователей. При попытке установить новый пароль, система должна проверять его с предыдущими паролями в таблице и блокировать создание пароля, если он совпадает с одним из старых.
- При восстановлении пароля пользователь должен ввести хотя бы один из старых паролей (или тот, который он помнит) для дополнительной проверки.
- Необходимо реализовать требования к сложности пароля, такие как наличие прописных и строчных букв, цифр, специальных символов (например, `@`, `#`, `%`, `&`)

### 3. Заполнять таблицу entryMonitoring

Необходимо обеспечить заполнение таблицы **`EntryMonitoring`** для мониторинга действий пользователей в системе. Для реализации данного функционала необходимо реализовать запись данных в таблицу **`EntryMonitoring`** при каждом действии пользователя (например, при авторизации, выходе из системы, изменении данных профиля и т.д.). 

Данный подход позволит оперативно отслеживать аномальные активности, например, частые попытки входа с разных IP-адресов, что может свидетельствовать о попытках взлома.

### 4. Возможность создания администратора

Для удобства управления системой и обеспечения первого доступа к функционалу администрирования необходимо реализовать возможность автоматического создания **пользователя с ролью "Администратор"** при запуске системы (сейчас это реализовано через подгрузку данных в БД). Реализация данного функционала возможна, например, через добавление вызова метода во views.py:

- При старте системы необходимо проверить, существует ли уже пользователь с ролью "Администратор".
- Если пользователя с ролью "Администратор" не существует, создается новый с заранее заданными данными (например, логин, пароль и роль).


### 5. Предоставить администраторам возможность "мягко" удалять пользователей

Необходимо предоставить пользователям с ролью **"Администратор"** возможность **мягкого удаления пользователей** из системы. Это позволит администраторам деактивировать пользователей, например, сотрудников, которые уволились.